#pragma once
#include "share_headers/config.h"
#include "share_headers/csv.h"
#include "share_headers/db_types.h"
#include "share_headers/logger.h"

#include "benchmark/flashbench/config.h"
#include "benchmark/flashbench/riz.h"
#include "benchmark/flashbench/schema.h"
#include "benchmark/utils/misc.h"
#include "benchmark/utils/rand.h"

#include "tbb/blocked_range.h"

#include <algorithm>
#include <array>
#include <cassert>
#include <cmath>
#include <csignal>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <iterator>
#include <map>
#include <memory>
#include <numeric>
#include <random>
#include <sstream>
#include <stdexcept>
#include <string>
#include <thread>
#include <vector>

using std::cout;
using std::endl;
using std::string;

class PatternGen {
public:
  enum class Pattern {
    Sequential,
    Uniform,
    Beta,
    Zones,
    Zipf,
    FioZipf, // trace generated by using FIO zipfian theta skew factor
    Traces,  // real-world workload traces (e.g., keyvalue, blkio, googletraces,
             // etc.)
    DB,      // mock db io traces
    ZNS,     // write requests as if it is using ZNS
    SeqZones
  };

  string pattern_string;
  const Pattern pattern;
  string zones_string;
  bool shuffle;
  const uint64_t logical_pages;
  double alpha;
  double beta;
  double skew_factor;
  uint64_t total_writes;
  uint64_t page_size;
  uint64_t request_size;
  uint64_t sector_size;

  std::atomic<uint64_t> seq = 0;

  std::uniform_int_distribution<uint64_t> rnd_page{0, logical_pages - 1};
  std::vector<uint64_t> update_pattern;
  bool trace_accessed_pages = false;

  struct AccessZone {
    uint64_t offset = 0;
    uint64_t count = 0;
    double rel_size = 1;
    double freq = 100;
    Pattern pattern = Pattern::Uniform;
    double skew_factor = 0;
    bool shuffle = false;
    std::unique_ptr<PatternGen> sub_gen; // recursive sub-pattern generator

    AccessZone(double rel_size, double rel_freq, Pattern pattern,
               double skew_factor, bool shuffle)
        : rel_size(rel_size), freq(rel_freq), pattern(pattern),
          skew_factor(skew_factor), shuffle(shuffle) {}

    void print() {
      std::cout << "{hint: o: " << offset << " c: " << count << " f: " << freq
                << " rels: " << rel_size;
      std::cout << " p: " << std::to_string((uint64_t)pattern)
                << " shuffle: " << shuffle << "}";
    }
  };

  std::vector<uint64_t> input_traces;
  size_t trace_index = 0;
  std::string trace_file_path;
  const size_t chunk_size =
      100000; // trace file chunk size to load on the memory

  std::vector<uint64_t> accessed_pages;

  // for ZNS like pattern
  std::vector<uint64_t> ZNS;

  // ZipfGenerator zipf_generator;
  //  zipf_generator(zipf_theta, initial_record_cnt),

  RejectionInversionZipfSampler zipf_sampler;

public:
  PatternGen(std::string pattern, uint64_t logical_cnt, std::string zones_str,
             double skew = 0.0, uint64_t total_wr = 10000,
             uint64_t request_size = 4096)
      : pattern_string(std::move(pattern)),
        pattern(StringToPattern(pattern_string)),
        zones_string(std::move(zones_string)),
        logical_pages(FLAGS_initial_dataset_size_gb * leanstore::GB /
                      GLOBAL_BLOCK_SIZE),
        skew_factor(FLAGS_zipf_factor),
        total_writes(logical_pages * FLAGS_exec_writes_pct *
                     (100 / (100 - FLAGS_read_ratio))),
        page_size(request_size), // Assuming page_size is meant to match
                                 // request_size here
        zipf_sampler(logical_pages, skew_factor),
        request_size(GLOBAL_BLOCK_SIZE),
        shuffle(pattern_string.find("shuffle") != std::string::npos &&
                pattern_string.find("noshuffle") == std::string::npos) {
    std::cout << "PatternGen: " << pattern_string << " zone: " << zones_string
              << "zipf factor: " << skew_factor << " shuffle: " << shuffle
              << " totalWrites: " << total_writes << std::endl;
    Init();
  }

  PatternGen(Pattern pattern, uint64_t logical_pages, double skew_factor = 0.0,
             bool shuffle = true)
      : pattern(pattern), logical_pages(logical_pages),
        skew_factor(skew_factor),
        total_writes(10000), // or any default that makes sense
        zipf_sampler(logical_pages, skew_factor), shuffle(shuffle) {
    Init();
  }

  static Pattern StringToPattern(const string &pattern) {
    if (pattern.find("sequential") != std::string::npos) {
      return Pattern::Sequential;
    } else if (pattern.find("uniform") != std::string::npos) {
      return Pattern::Uniform;
    } else if (pattern.find("beta") != std::string::npos) {
      return Pattern::Beta;
    } else if (pattern.find("seqzones") != std::string::npos) {
      return Pattern::SeqZones;
    } else if (pattern.find("zones") != std::string::npos) {
      return Pattern::Zones;
    } else if (pattern.find("fiozipf") != std::string::npos) {
      return Pattern::FioZipf;
    } else if (pattern.find("zipf") != std::string::npos) {
      return Pattern::Zipf;
    } else if (pattern.find("trace") != std::string::npos) {
      return Pattern::Traces;
    } else if (pattern.find("mockdb") != std::string::npos) {
      return Pattern::DB;
    } else if (pattern.find("zns") != std::string::npos) {
      return Pattern::ZNS;
    } else {
      UnreachableCode();
    }
  }

  std::string PatternDetails() {
    std::string pattern_details;
    if (pattern == Pattern::Zones || pattern == Pattern::SeqZones) {
      pattern_details = zones_string;
    } else if (pattern == Pattern::Beta) {
      pattern_details =
          "a:" + std::to_string(alpha) + " b:" + std::to_string(beta);
    } else if (pattern == Pattern::Zipf || pattern == Pattern::FioZipf) {
      pattern_details = std::to_string(skew_factor);
    }
    return pattern_details;
  }

  void Init() {
    if (this->pattern == Pattern::FioZipf) {
    } else if (this->pattern == Pattern::Traces) {
    } else if (this->pattern == Pattern::Zones) {
      ParseAndInitZoneAccessPattern();
    } else if (this->pattern == Pattern::SeqZones) {
      ParseAndInitSeqZoneAccessPattern();
    }
    if (shuffle) {
      update_pattern.resize(logical_pages);
      for (uint64_t i = 0; i < update_pattern.size(); i++) {
        update_pattern[i] = i;
      }
      std::random_device rd;
      std::mt19937_64 g(rd());
      std::shuffle(update_pattern.begin(), update_pattern.end(), g);
    }
  }

  uint64_t AccessPatternGenerator(std::mt19937_64 &gen) {
    uint64_t page = 0;
    if (pattern == Pattern::Sequential) {

      page = seq++ % logical_pages;
    } else if (pattern == Pattern::Uniform) {
      page = rnd_page(gen);
      // LOG_INFO("pid: %lu", page);
    } else if (pattern == Pattern::SeqZones) {
      page = AccessZonesGenerator(gen);
    } else if (pattern == Pattern::Zones) {
      page = AccessZonesGenerator(gen);
    } else if (pattern == Pattern::Beta) {
      // double beta_val = beta_distribution(gen, alpha, beta);
      //  page = beta_val * (logical_pages - 1);
    } else if (pattern == Pattern::Zipf) {
      page = zipf_sampler.sample(gen) - 1;
      // page = zipf_generator.Rand();
      // LOG_INFO("pid: %lu skew factor: %f request size :%lu", page,
      // skew_factor, logical_pages);
    }
    if (shuffle) {
      page = update_pattern.at(page);
    }
    if (trace_accessed_pages) {
      accessed_pages.push_back(page);
    }
    return page;
  }

  double sum_freq = 0;
  std::vector<AccessZone> access_zones;

  void ParseZoneSizes(const std::string &str) {
    LOG_INFO("%s", str);
    std::stringstream ss(str);
    std::string value;
    double size = -1;
    double freq = -1;
    Pattern pattern = Pattern::Uniform;
    double skew_factor = -1;
    bool shuffle = false;

    auto add_zone = [&]() {
      if (size > 0 && freq > 0) {
        access_zones.emplace_back(size, freq, pattern, skew_factor, shuffle);
        size = -1;
        freq = -1;
        pattern = Pattern::Uniform;
        skew_factor = -1;
        shuffle = false;
      }
    };

    while (ss >> value) {
      if (value[0] == 's' && value != "shuffle" && value != "sequential") {
        add_zone();
        size = std::stod(value.substr(1));
      } else if (value[0] == 'f') {
        freq = std::stod(value.substr(1));
      } else if (value == "uniform") {
        pattern = Pattern::Uniform;
      } else if (value.substr(0, 4) == "zipf") {
        pattern = Pattern::Zipf;
        skew_factor =
            value.size() > 4 ? std::stod(value.substr(4)) : skew_factor;
      } else if (value == "sequential") {
        pattern = Pattern::Sequential;
      } else if (value == "shuffle") {
        shuffle = true;
      }
    }
    add_zone();

    sum_freq = std::accumulate(
        access_zones.begin(), access_zones.end(), 0.0,
        [](double sum, const AccessZone &zone) { return sum + zone.freq; });
  }

  void ParseAndInitZoneAccessPattern() {
    ParseZoneSizes(zones_string);

    uint64_t current_offset = 0;
    for (auto &zone : access_zones) {
      zone.count = logical_pages * zone.rel_size;
      zone.offset = current_offset;
      current_offset += zone.count;
      zone.sub_gen = std::make_unique<PatternGen>(
          zone.pattern, zone.count, zone.skew_factor, zone.shuffle);
    }
  }

  uint64_t AccessZonesGenerator(std::mt19937_64 &gen) {
    double rand_freq = std::uniform_real_distribution<>(0, sum_freq)(gen);
    for (const auto &zone : access_zones) {
      if ((rand_freq -= zone.freq) <= 0) {
        return zone.offset + zone.sub_gen->AccessPatternGenerator(gen);
      }
    }
    assert(false);
    return 0;
  }

  void ParseAndInitSeqZoneAccessPattern() {
    ZNS.resize(logical_pages);
    std::iota(ZNS.begin(), ZNS.end(), 0);
  }
};
